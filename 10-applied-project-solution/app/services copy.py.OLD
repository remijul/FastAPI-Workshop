"""
Services contenant la logique mÃ©tier.
SOLUTION COMPLÃˆTE
"""

from app.repositories import CharacterRepository
from app.models import CharacterCreate, CharacterUpdate, CharacterResponse
from app.exceptions import CharacterNotFoundError, MaxLevelReachedError
from typing import Optional
from datetime import datetime


class CharacterService:
    """Service pour la logique mÃ©tier des personnages."""
    
    @staticmethod
    def create_character(character_data: CharacterCreate) -> CharacterResponse:
        """CrÃ©e un nouveau personnage."""
        character_id = CharacterRepository.create(
            name=character_data.name,
            character_class=character_data.character_class,
            level=character_data.level,
            health_points=character_data.health_points,
            attack=character_data.attack,
            defense=character_data.defense,
            speed=character_data.speed,
            special_ability=character_data.special_ability,
            image_url=character_data.image_url
        )
        
        # RÃ©cupÃ©rer le personnage crÃ©Ã©
        created_character = CharacterRepository.get_by_id(character_id)
        
        return CharacterResponse(
            id=created_character["id"],
            name=created_character["name"],
            character_class=created_character["class"],
            level=created_character["level"],
            health_points=created_character["health_points"],
            attack=created_character["attack"],
            defense=created_character["defense"],
            speed=created_character["speed"],
            special_ability=created_character["special_ability"],
            image_url=created_character["image_url"],
            created_at=created_character["created_at"]
        )
    
    @staticmethod
    def get_character(character_id: int) -> CharacterResponse:
        """RÃ©cupÃ¨re un personnage par ID."""
        character = CharacterRepository.get_by_id(character_id)
        
        if not character:
            raise CharacterNotFoundError(character_id)
        
        return CharacterResponse(
            id=character["id"],
            name=character["name"],
            character_class=character["class"],
            level=character["level"],
            health_points=character["health_points"],
            attack=character["attack"],
            defense=character["defense"],
            speed=character["speed"],
            special_ability=character["special_ability"],
            image_url=character["image_url"],
            created_at=character["created_at"]
        )
    
    @staticmethod
    def get_all_characters() -> list[CharacterResponse]:
        """RÃ©cupÃ¨re tous les personnages."""
        characters = CharacterRepository.get_all()
        
        return [
            CharacterResponse(
                id=char["id"],
                name=char["name"],
                character_class=char["class"],
                level=char["level"],
                health_points=char["health_points"],
                attack=char["attack"],
                defense=char["defense"],
                speed=char["speed"],
                special_ability=char["special_ability"],
                image_url=char["image_url"],
                created_at=char["created_at"]
            )
            for char in characters
        ]
    
    @staticmethod
    def update_character(character_id: int, 
                        character_data: CharacterUpdate) -> CharacterResponse:
        """Met Ã  jour un personnage."""
        # VÃ©rifier que le personnage existe
        existing = CharacterRepository.get_by_id(character_id)
        if not existing:
            raise CharacterNotFoundError(character_id)
        
        # Extraire seulement les champs fournis
        updates = character_data.model_dump(exclude_unset=True, by_alias=True)
        
        if updates:
            # Convertir l'alias "class" en "class" pour la DB
            if "class" in updates:
                updates["class"] = updates["class"]
            
            CharacterRepository.update(character_id, **updates)
        
        # Retourner le personnage mis Ã  jour
        return CharacterService.get_character(character_id)
    
    @staticmethod
    def delete_character(character_id: int) -> None:
        """Supprime un personnage."""
        # VÃ©rifier que le personnage existe
        existing = CharacterRepository.get_by_id(character_id)
        if not existing:
            raise CharacterNotFoundError(character_id)
        
        CharacterRepository.delete(character_id)
    
    # ==================== NIVEAU 2 ====================
    
    @staticmethod
    def get_characters_filtered(character_class: Optional[str] = None,
                               min_level: Optional[int] = None,
                               max_level: Optional[int] = None) -> list[CharacterResponse]:
        """RÃ©cupÃ¨re les personnages avec filtres."""
        characters = CharacterRepository.get_by_filters(
            character_class=character_class,
            min_level=min_level,
            max_level=max_level
        )
        
        return [
            CharacterResponse(
                id=char["id"],
                name=char["name"],
                character_class=char["class"],
                level=char["level"],
                health_points=char["health_points"],
                attack=char["attack"],
                defense=char["defense"],
                speed=char["speed"],
                special_ability=char["special_ability"],
                image_url=char["image_url"],
                created_at=char["created_at"]
            )
            for char in characters
        ]
    
    @staticmethod
    def get_statistics() -> dict:
        """RÃ©cupÃ¨re les statistiques globales."""
        return CharacterRepository.get_stats()
    
    @staticmethod
    def level_up(character_id: int) -> CharacterResponse:
        """Augmente le niveau d'un personnage de 1."""
        # RÃ©cupÃ©rer le personnage
        character = CharacterRepository.get_by_id(character_id)
        
        if not character:
            raise CharacterNotFoundError(character_id)
        
        # VÃ©rifier qu'il n'est pas dÃ©jÃ  niveau 100
        if character["level"] >= 100:
            raise MaxLevelReachedError(character_id)
        
        # Augmenter les stats
        updates = {
            "level": character["level"] + 1,
            "health_points": character["health_points"] + 10,
            "attack": character["attack"] + 2,
            "defense": character["defense"] + 1
        }
        
        CharacterRepository.update(character_id, **updates)
        
        # Retourner le personnage mis Ã  jour
        return CharacterService.get_character(character_id)


# ==================== NIVEAU 3 - OPTION COMBAT ====================

class BattleService:
    """Service pour gÃ©rer les combats entre personnages."""
    
    @staticmethod
    def simulate_battle(character1_id: int, character2_id: int) -> dict:
        """Simule un combat entre deux personnages."""
        # RÃ©cupÃ©rer les personnages
        char1_data = CharacterRepository.get_by_id(character1_id)
        char2_data = CharacterRepository.get_by_id(character2_id)
        
        if not char1_data:
            raise CharacterNotFoundError(character1_id)
        if not char2_data:
            raise CharacterNotFoundError(character2_id)
        
        # CrÃ©er des copies des HP pour le combat
        char1_hp = char1_data["health_points"]
        char2_hp = char2_data["health_points"]
        
        battle_log = []
        turns = 0
        
        # DÃ©terminer qui attaque en premier (plus rapide)
        if char1_data["speed"] >= char2_data["speed"]:
            attacker = (char1_data, "char1_hp")
            defender = (char2_data, "char2_hp")
            attacker_hp_var = "char1_hp"
            defender_hp_var = "char2_hp"
        else:
            attacker = (char2_data, "char2_hp")
            defender = (char1_data, "char1_hp")
            attacker_hp_var = "char2_hp"
            defender_hp_var = "char1_hp"
        
        battle_log.append(f"âš”ï¸ Combat entre {char1_data['name']} et {char2_data['name']}")
        battle_log.append(f"ğŸƒ {attacker[0]['name']} attaque en premier (vitesse: {attacker[0]['speed']})")
        
        # Boucle de combat
        while char1_hp > 0 and char2_hp > 0:
            turns += 1
            
            # Attaquant actuel
            if attacker[0]["id"] == char1_data["id"]:
                current_attacker = char1_data
                current_defender = char2_data
                attacker_hp = char1_hp
                defender_hp = char2_hp
            else:
                current_attacker = char2_data
                current_defender = char1_data
                attacker_hp = char2_hp
                defender_hp = char1_hp
            
            # Calcul des dÃ©gÃ¢ts
            damage = max(1, current_attacker["attack"] - current_defender["defense"])
            
            # Appliquer les dÃ©gÃ¢ts
            if current_defender["id"] == char1_data["id"]:
                char1_hp -= damage
                battle_log.append(
                    f"Tour {turns}: {current_attacker['name']} inflige {damage} dÃ©gÃ¢ts Ã  {current_defender['name']} "
                    f"(HP restants: {max(0, char1_hp)})"
                )
            else:
                char2_hp -= damage
                battle_log.append(
                    f"Tour {turns}: {current_attacker['name']} inflige {damage} dÃ©gÃ¢ts Ã  {current_defender['name']} "
                    f"(HP restants: {max(0, char2_hp)})"
                )
            
            # VÃ©rifier si le combat est terminÃ©
            if char1_hp <= 0 or char2_hp <= 0:
                break
            
            # Inverser attaquant et dÃ©fenseur
            attacker, defender = defender, attacker
        
        # DÃ©terminer le gagnant
        if char1_hp > 0:
            winner = char1_data
            winner_hp = char1_hp
            loser = char2_data
        else:
            winner = char2_data
            winner_hp = char2_hp
            loser = char1_data
        
        battle_log.append(f"ğŸ† {winner['name']} remporte le combat avec {winner_hp} HP restants!")
        
        return {
            "winner_id": winner["id"],
            "winner_name": winner["name"],
            "loser_id": loser["id"],
            "loser_name": loser["name"],
            "turns": turns,
            "winner_remaining_hp": winner_hp,
            "battle_log": battle_log
        }


# ==================== NIVEAU 3 - OPTION AUTH ====================

from app.repositories import UserRepository
from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class AuthService:
    """Service pour l'authentification."""
    
    @staticmethod
    def register(username: str, password: str) -> bool:
        """Enregistre un utilisateur."""
        # VÃ©rifier si l'utilisateur existe dÃ©jÃ 
        existing = UserRepository.get_by_username(username)
        if existing:
            return False
        
        # Hacher le mot de passe
        hashed_password = pwd_context.hash(password)
        
        # CrÃ©er l'utilisateur
        UserRepository.create(username, hashed_password)
        return True
    
    @staticmethod
    def authenticate(username: str, password: str) -> bool:
        """Authentifie un utilisateur."""
        user = UserRepository.get_by_username(username)
        
        if not user:
            return False
        
        return pwd_context.verify(password, user["hashed_password"])